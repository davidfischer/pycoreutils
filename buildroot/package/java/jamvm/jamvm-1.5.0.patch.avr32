diff -urpN jamvm-1.5.0/configure jamvm-1.5.0-avr32/configure
--- jamvm-1.5.0/configure	2007-10-29 06:37:06.000000000 +0100
+++ jamvm-1.5.0-avr32/configure	2008-02-08 09:20:37.000000000 +0100
@@ -2550,6 +2550,7 @@ i386-*-openbsd*) host_os=bsd libdl_neede
 i386-*-freebsd*) host_os=bsd libdl_needed=no ;;
 x86_64-*-linux*) host_os=linux ;;
 hppa*-*-linux*) host_cpu=parisc host_os=linux ;;
+avr32*-*-linux*) host_cpu=avr32 host_os=linux ;;
 mipsel-*-linux*) host_cpu=mips host_os=linux ;;
 amd64-*-openbsd*) host_os=bsd libdl_needed=no ;;
 amd64-*-freebsd*) host_os=bsd libdl_needed=no ;;
@@ -22839,7 +22840,7 @@ fi
 ac_config_links="$ac_config_links src/arch.h:src/arch/$arch.h"
 
 
-ac_config_files="$ac_config_files Makefile src/Makefile src/interp/Makefile src/interp/engine/Makefile src/arch/Makefile src/os/Makefile src/os/linux/Makefile src/os/darwin/Makefile src/os/bsd/Makefile src/os/linux/powerpc/Makefile src/os/linux/arm/Makefile src/os/linux/i386/Makefile src/os/linux/x86_64/Makefile src/os/linux/parisc/Makefile src/os/linux/mips/Makefile src/os/darwin/i386/Makefile src/os/darwin/powerpc/Makefile src/os/bsd/powerpc/Makefile src/os/bsd/arm/Makefile src/os/bsd/i386/Makefile src/os/bsd/x86_64/Makefile lib/Makefile lib/java/Makefile lib/java/lang/Makefile lib/jamvm/Makefile lib/jamvm/java/Makefile lib/jamvm/java/lang/Makefile lib/java/lang/reflect/Makefile lib/java/security/Makefile lib/gnu/Makefile lib/sun/reflect/annotation/Makefile lib/sun/reflect//Makefile lib/sun/Makefile lib/gnu/classpath/Makefile"
+ac_config_files="$ac_config_files Makefile src/Makefile src/interp/Makefile src/interp/engine/Makefile src/arch/Makefile src/os/Makefile src/os/linux/Makefile src/os/darwin/Makefile src/os/bsd/Makefile src/os/linux/powerpc/Makefile src/os/linux/arm/Makefile src/os/linux/i386/Makefile src/os/linux/x86_64/Makefile src/os/linux/avr32/Makefile src/os/linux/parisc/Makefile src/os/linux/mips/Makefile src/os/darwin/i386/Makefile src/os/darwin/powerpc/Makefile src/os/bsd/powerpc/Makefile src/os/bsd/arm/Makefile src/os/bsd/i386/Makefile src/os/bsd/x86_64/Makefile lib/Makefile lib/java/Makefile lib/java/lang/Makefile lib/jamvm/Makefile lib/jamvm/java/Makefile lib/jamvm/java/lang/Makefile lib/java/lang/reflect/Makefile lib/java/security/Makefile lib/gnu/Makefile lib/sun/reflect/annotation/Makefile lib/sun/reflect//Makefile lib/sun/Makefile lib/gnu/classpath/Makefile"
 
 
 cat >confcache <<\_ACEOF
@@ -23475,6 +23476,7 @@ do
     "src/os/linux/i386/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/linux/i386/Makefile" ;;
     "src/os/linux/x86_64/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/linux/x86_64/Makefile" ;;
     "src/os/linux/parisc/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/linux/parisc/Makefile" ;;
+    "src/os/linux/avr32/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/linux/avr32/Makefile" ;;
     "src/os/linux/mips/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/linux/mips/Makefile" ;;
     "src/os/darwin/i386/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/darwin/i386/Makefile" ;;
     "src/os/darwin/powerpc/Makefile") CONFIG_FILES="$CONFIG_FILES src/os/darwin/powerpc/Makefile" ;;
diff -urpN jamvm-1.5.0/src/alloc.c jamvm-1.5.0-avr32/src/alloc.c
--- jamvm-1.5.0/src/alloc.c	2007-10-22 01:24:22.000000000 +0200
+++ jamvm-1.5.0-avr32/src/alloc.c	2008-02-08 09:20:38.000000000 +0100
@@ -274,6 +274,11 @@ void initialiseAlloc(InitArgs *args) {
 #else
     char *mem = (char*)mmap(0, args->max_heap, PROT_READ|PROT_WRITE,
                                                MAP_PRIVATE|MAP_ANON, -1, 0);
+//    char *mem = (char*)mmap(0, 8196, PROT_READ|PROT_WRITE,
+//                                               MAP_PRIVATE|MAP_ANON, -1, 0);
+//TODO: lto
+//jam_printf("trying to mmap max:%lo min:%lo heap\n",args->max_heap , args->max_heap);
+//jam_printf("mem: %d %d\n",mem,MAP_FAILED);
     if(mem == MAP_FAILED) {
 #endif
         perror("Aborting the VM -- couldn't allocate the heap");
@@ -2214,7 +2219,7 @@ void *sysMalloc(int size) {
     int n = size < sizeof(void*) ? sizeof(void*) : size;
     void *mem = malloc(n);
 
-    if(mem == NULL) {
+    if(mem == NULL && n != 0) {
         jam_fprintf(stderr, "Malloc failed - aborting VM...\n");
         exitVM(1);
     }
diff -urpN jamvm-1.5.0/src/arch/avr32.h jamvm-1.5.0-avr32/src/arch/avr32.h
--- jamvm-1.5.0/src/arch/avr32.h	1970-01-01 01:00:00.000000000 +0100
+++ jamvm-1.5.0-avr32/src/arch/avr32.h	2008-02-08 09:20:41.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2003, 2004, 2005, 2006, 2007
+ * Robert Lougher <rob@lougher.org.uk>.
+ *
+ * This file is part of JamVM.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#define OS_ARCH "avr32"
+//#ifndef DEBUG
+//#define DEBUG
+//#endif
+
+/* Override default min and max heap sizes.  AVR32 machines are
+   usually embedded, and the standard defaults are too large. */
+#define DEFAULT_MAX_HEAP 8*MB
+#define DEFAULT_MIN_HEAP 1*MB
+
+#define HANDLER_TABLE_T static const void
+#define DOUBLE_1_BITS 0x3ff0000000000000LL
+
+#define READ_DBL(v,p,l)	v = ((u8)p[0]<<56)|((u8)p[1]<<48)|((u8)p[2]<<40) \
+                            |((u8)p[3]<<32)|((u8)p[4]<<24)|((u8)p[5]<<16) \
+                            |((u8)p[6]<<8)|(u8)p[7]; p+=8
+
+//extern void setDoublePrecision();
+#define FPU_HACK
+
+//#define COMPARE_AND_SWAP(addr, old_val, new_val)    ({char result;result;})
+//static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned int old,
+//					  unsigned int new)
+//{
+//	int ret;
+//	//printf("compare and swap %d %d %s:line%d\n",old,new,__FILE__,__LINE__);
+//	asm volatile(
+//		"1:	ssrf	5\n"
+//		"	ld.w	%[ret], %[m]\n"
+//		"	cp.w		%[ret], %[old]\n"
+//		"	brne	2f\n"
+//		"	stcond	%[m], %[new]\n"
+//		"	brne	1b\n"
+//		"2:\n"
+//		: [ret] "=&r"(ret), [m] "=m"(*m)
+//		: "m"(*m), [new] "r"(new), [old] "r"(old)
+//		: "memory", "cc");
+//	return ret;
+//}
+
+//see C:\Cygwin\usr\local\avr32-linux\include\bits\atomicity.h
+//see http://www.avr32linux.org/twiki/bin/view/Main/AtomicOperations
+//see http://www.mail-archive.com/uclibc@uclibc.org/msg00914.html
+//http://www.avr32linux.org/twiki/pub/Main/MicroClibcPatches/uClibc-0.9.28-avr32-20060621.patch
+//http://www.google.com/codesearch?hl=en&q=+cmpxchg+avr32+show:WwwDfOAAdbA:L2BlPHy6h_g:nY7RakaTOnE&sa=N&cd=1&ct=rc&cs_p=http://gobo.calica.com/packages/official/Linux--2.6.20.4-r1--i686.tar.bz2&cs_f=Linux/2.6.20.4/Resources/Unmanaged/Files/Compile/Sources/linux-2.6.20.4/include/asm-avr32/system.h#first
+//#define  COMPARE_AND_SWAP(p, oldval, newval)({	\
+//	printf("compare and swap %d %d %s:line%d\n",oldval,newval,__FILE__,__LINE__);	\ 
+//	__cmpxchg_u32(p,oldval,newval);\
+//})
+
+//	printf("compare and swap %d %d %s:line %d\n",old_val,new_val,__FILE__,__LINE__); 
+#define COMPARE_AND_SWAP(addr, old_val, new_val)	    			\
+({                                                  	\
+	int result;											\
+	__asm__ __volatile__ ("								\
+		1:	ssrf	5;									\
+			ld.w	%[ret], %[m];						\
+			cp.w	%[ret], %[old];						\
+			brne	2f;									\
+			stcond	%[m], %[new];						\
+			brne	1b;									\
+		2:"												\
+		: [ret] "=&r" (result), [m] "=m" (*addr)		\
+		: "m" (*addr), [old] "r" (old_val), [new] "r" (new_val)	\
+		: "memory", "cc");								\
+	result;												\
+})
+
+//ssrf 5	:set lock bit
+//stcond	:store param2 when lock is set
+//sreq		:If equal set register to true or false
+//brne		:Branch when not equal
+//brne 1b	:When the lock wasn't set anymore, try again
+//label 1b 2f	:first label named 1/2 before/after
+#define FLUSH_CACHE(addr, length)
+
+#define LOCKWORD_READ(addr) *addr
+#define LOCKWORD_WRITE(addr, value) *addr = value
+#define LOCKWORD_COMPARE_AND_SWAP(addr, old_val, new_val) \
+        COMPARE_AND_SWAP(addr, old_val, new_val)
+
+#define UNLOCK_MBARRIER() __asm__ __volatile__ ("" ::: "memory")
+#define JMM_LOCK_MBARRIER() __asm__ __volatile__ ("" ::: "memory")
+#define JMM_UNLOCK_MBARRIER() __asm__ __volatile__ ("" ::: "memory")
+
+//TODO: lto
+#define MBARRIER() __asm__ __volatile__ ("" ::: "memory")
+//#define MBARRIER() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" ::: "memory")
diff -urpN jamvm-1.5.0/src/arch/Makefile.am jamvm-1.5.0-avr32/src/arch/Makefile.am
--- jamvm-1.5.0/src/arch/Makefile.am	2007-10-28 00:19:26.000000000 +0200
+++ jamvm-1.5.0-avr32/src/arch/Makefile.am	2008-02-08 09:20:41.000000000 +0100
@@ -19,4 +19,4 @@
 ## Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 ##
 
-EXTRA_DIST = powerpc.h arm.h i386.h x86_64.h parisc.h mips.h
+EXTRA_DIST = powerpc.h arm.h i386.h x86_64.h parisc.h mips.h avr32.h
diff -urpN jamvm-1.5.0/src/arch/Makefile.in jamvm-1.5.0-avr32/src/arch/Makefile.in
--- jamvm-1.5.0/src/arch/Makefile.in	2007-10-29 07:02:36.000000000 +0100
+++ jamvm-1.5.0-avr32/src/arch/Makefile.in	2008-02-08 09:20:41.000000000 +0100
@@ -162,7 +162,7 @@ top_srcdir = @top_srcdir@
 use_zip_no = @use_zip_no@
 use_zip_yes = @use_zip_yes@
 with_classpath_install_dir = @with_classpath_install_dir@
-EXTRA_DIST = powerpc.h arm.h i386.h x86_64.h parisc.h mips.h
+EXTRA_DIST = powerpc.h arm.h i386.h x86_64.h parisc.h mips.h avr32.h
 all: all-am
 
 .SUFFIXES:
diff -urpN jamvm-1.5.0/src/class.c jamvm-1.5.0-avr32/src/class.c
--- jamvm-1.5.0/src/class.c	2007-10-29 05:45:32.000000000 +0100
+++ jamvm-1.5.0-avr32/src/class.c	2008-02-08 09:20:37.000000000 +0100
@@ -40,6 +40,8 @@
 #define SCAVENGE(ptr) FALSE
 #define FOUND(ptr) ptr
 
+#define TRACE(fmt, ...) jam_printf(fmt, ## __VA_ARGS__)
+
 static int verbose;
 static char *bootpath;
 static char *classpath;
@@ -1273,6 +1275,9 @@ Class *findSystemClass0(char *classname)
 }
 
 Class *findSystemClass(char *classname) {
+#ifdef DEBUG
+  	TRACE(">>>>>>finding class: %s\n", classname);
+#endif
    Class *class = findSystemClass0(classname);
 
    if(!exceptionOccurred())
@@ -1383,18 +1388,32 @@ Class *findClassFromClassLoader(char *cl
 }
 
 Object *getSystemClassLoader() {
+#ifdef DEBUG
+	printf("%s: %d: trying to find ClassLoader\n",__FILE__,__LINE__);
+#endif
     Class *class_loader = findSystemClass("java/lang/ClassLoader");
 
     if(!exceptionOccurred()) {
+#ifdef DEBUG
+    	printf("%s: %d: found ClassLoader\n",__FILE__,__LINE__);
+#endif    	
         MethodBlock *mb;
 
         if((mb = findMethod(class_loader, "getSystemClassLoader",
                                           "()Ljava/lang/ClassLoader;")) != NULL) {
+#ifdef DEBUG
+            printf("%s: %d: executing static SystemClassLoader",__FILE__,__LINE__);
+#endif
+                                          	
             Object *system_loader = *(Object**)executeStaticMethod(class_loader, mb);
 
             if(!exceptionOccurred()) 
                 return system_loader;
         }
+#ifdef DEBUG
+    }else{
+    	printf("%s: %d: found ClassLoader WITH EXCEPTION\n",__FILE__,__LINE__);
+#endif
     }
     return NULL;
 }
diff -urpN jamvm-1.5.0/src/interp/direct.c jamvm-1.5.0-avr32/src/interp/direct.c
--- jamvm-1.5.0/src/interp/direct.c	2007-10-26 05:10:47.000000000 +0200
+++ jamvm-1.5.0-avr32/src/interp/direct.c	2008-02-08 09:20:40.000000000 +0100
@@ -31,7 +31,7 @@
 #include "interp.h"
 
 #ifdef TRACEDIRECT
-#define TRACE(fmt, ...) jam_printf(fmt, ## __VA_ARGS__)
+#define TRACE(fmt, ...) printf(fmt, ## __VA_ARGS__)
 #else
 #define TRACE(fmt, ...)
 #endif
Binary files jamvm-1.5.0/src/interp/engine/compute_relocatability and jamvm-1.5.0-avr32/src/interp/engine/compute_relocatability differ
diff -urpN jamvm-1.5.0/src/os/linux/avr32/dll_md.c jamvm-1.5.0-avr32/src/os/linux/avr32/dll_md.c
--- jamvm-1.5.0/src/os/linux/avr32/dll_md.c	1970-01-01 01:00:00.000000000 +0100
+++ jamvm-1.5.0-avr32/src/os/linux/avr32/dll_md.c	2008-02-08 09:20:38.000000000 +0100
@@ -0,0 +1,669 @@
+/*
+ * Copyright (C) 2003, 2004, 2005, 2006, 2007
+ * Robert Lougher <rob@lougher.org.uk>.
+ *
+ * This file is part of JamVM.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include "../../../jam.h"
+
+#ifndef USE_FFI
+#include <string.h>
+#include "../../../sig.h"
+
+#define RET_VOID    0
+#define RET_DOUBLE  1
+#define RET_LONG    2
+#define RET_FLOAT   3
+#define RET_DFLT    4
+
+int nativeExtraArg(MethodBlock *mb) {
+	//printf("!!!!!!!!!!nativeExtraArg (name=%s) (type=%s)!!!!!!!\n",mb->name,mb->type);
+    int len = strlen(mb->type);
+    if(mb->type[len-2] == ')')
+        switch(mb->type[len-1]) {
+            case 'V':
+                return RET_VOID;
+            case 'D':
+                return RET_DOUBLE;
+            case 'J':
+                return RET_LONG;
+            case 'F':
+                return RET_FLOAT;
+        }
+
+    return RET_DFLT;
+}
+
+//calls the f function pointer and takes care of the return type
+#define perform_f(label,...)													\
+		switch(ret_type) {														\
+        	case RET_VOID:														\
+            	(*(void (*)())f)(__VA_ARGS__);									\
+				goto label;														\
+        	case RET_DOUBLE:													\
+	        	*(double*)ostack = (*(double (*)())f)(__VA_ARGS__);				\
+            	ostack += 2;													\
+				goto label;														\
+        	case RET_LONG:														\
+	        	*(long long*)ostack = (*(long long (*)())f)(__VA_ARGS__);		\
+            	ostack += 2;													\
+				goto label;														\
+        	case RET_FLOAT:														\
+	        	*(float*)ostack = (*(float (*)())f)(__VA_ARGS__);				\
+            	ostack++;														\
+				goto label;														\
+        	default:															\
+	            *ostack++ = (*(u4 (*)())f)(__VA_ARGS__);						\
+				goto label;														\
+	    }
+
+#define write_ops_to_stack(x)	    											\
+	/*write x operands to the stack	*/											\
+	int i;																		\
+	for(i=0; i < x; i++){														\
+		__asm__ __volatile__(													\
+    	"ld.w r11,%0		\n\t"												\
+    	"st.w --sp,r11		" 													\
+    	:: "m"(*--opntr)														\
+    	:"sp","r11");															\
+	}										
+	
+u4 *callJNIMethod(void *env, Class *class, char *sig, int ret_type, u4 *ostack, unsigned char *f, int args) {
+	u4 *opntr = ostack + args;
+	int nrofopsonstack = 0;
+	if(class && args > 3){
+		nrofopsonstack = args - 3;
+	}else if(class){
+		nrofopsonstack = 0;
+	}else if(args > 4){
+		nrofopsonstack = args -4;
+	}else{
+		nrofopsonstack = 0;
+	}
+	
+	if(args == 0){
+		if(class){
+			perform_f(done,env,class);
+		}else{
+			perform_f(done,env);
+		}
+	}else if(args == 1){
+		if(class){
+    		perform_f(done,env,class,*--opntr);
+		}else{
+    		perform_f(done,env,*--opntr);
+		}
+	}else if(args == 2){
+		if(class){
+    		perform_f(done,env,class,*--opntr,*--opntr);
+		}else{
+    		perform_f(done,env,*--opntr,*--opntr);
+		}
+	}else if(args == 3){
+		if(class){
+    		perform_f(done,env,class,*--opntr,*--opntr,*--opntr);
+		}else{
+    		perform_f(done,env,*--opntr,*--opntr,*--opntr);
+		}
+	}else{
+		write_ops_to_stack(nrofopsonstack)
+		if(class){
+    		perform_f(empty_stack,env,class,*--opntr,*--opntr,*--opntr);
+		}else{
+    		perform_f(empty_stack,env,*--opntr,*--opntr,*--opntr,*--opntr);
+		}
+	}
+	
+	empty_stack:
+	//Increment stack pointer to loose all operands we put there
+	if(nrofopsonstack > 0) {
+ 		__asm__ __volatile__("add sp,%0" ::"r"((nrofopsonstack) * sizeof(u4)): "sp");
+	}
+		
+	done:
+	return ostack;
+}
+
+/*
+    int i;
+    int nrofopsonstack,nrofopsinregister;
+	u4 *opntr = ostack + args;
+	register int *r5 asm ("r5");
+	*r5 = *f;
+	
+//	register unsigned char *r6 asm ("r6");
+//	register int *r7 asm ("r7");
+//	register int *r8 asm ("r8");
+//	register int *r9 asm ("r9");
+//	register int *r10 asm ("r10");
+//	register int *r11 asm ("r11");
+//	register int *r12 asm ("r12");
+	
+	if(class && args > 3){
+		nrofopsonstack = args - 3;
+		nrofopsinregister = 3;
+	}else if(class){
+		nrofopsonstack = 0;
+		nrofopsinregister = args;
+	}else if(args > 4){
+		nrofopsonstack = args -4;
+		nrofopsinregister = 4;
+	}else{
+		nrofopsonstack = 0;
+		nrofopsinregister = args;
+	}
+
+	//write all operands except 3 or 4 to the stack	
+	for(i=0; i < nrofopsonstack; i++){
+		//printf("!!!!!writing arg %d to stack\n",i);
+    	__asm__ __volatile__(
+    	"ld.w r11,%0		\n\t"
+    	"st.w --sp,r11		" 
+    	:: "m"(*--opntr)
+    	:"sp","r11");
+	}
+
+	
+	//TODO: make sure none of the registers above have been changed
+	switch(ret_type) {
+        case RET_VOID:
+        	goto do_void_function;
+        case RET_DOUBLE:
+        	goto do_double_function;
+        case RET_LONG:
+        	goto do_longlong_function;
+        case RET_FLOAT:
+        	goto do_float_function;
+        default:
+        	goto do_default_function;
+    }
+
+	do_void_function:
+			WRITE_PARAMS(label_void)
+			__asm__ __volatile__(
+				"icall r5"
+				::"m"(f));
+			label_void:
+            (*(void (*)())f)();
+            //printf("!!!!!!!!!!!!! called void JNIMethod %s!!!!!!!!!!\n",sig);
+            goto empty_stack;
+            
+	do_double_function:
+			WRITE_PARAMS(label_double)
+			label_double:
+        	*(double*)ostack = (*(double (*)())f)();
+            ostack += 2;
+            //printf("!!!!!!!!!!!!! called double JNIMethod %s %l!!!!!!!!!!\n",sig,*ostack);
+            goto empty_stack;
+
+	do_longlong_function:
+			WRITE_PARAMS(label_longlong)
+			label_longlong:
+        	*(long long*)ostack = (*(long long (*)())f)();
+            ostack += 2;
+            //printf("!!!!!!!!!!!!! called long JNIMethod %s %l!!!!!!!!!!\n",sig,*ostack);
+            goto empty_stack;
+
+	do_float_function:
+			WRITE_PARAMS(label_float)
+			label_float:
+        	*(float*)ostack = (*(float (*)())f)();
+            ostack++;
+            //printf("!!!!!!!!!!!!! called float JNIMethod %s %f!!!!!!!!!!\n",sig,*ostack);
+            goto empty_stack;
+
+	do_default_function:
+			WRITE_PARAMS(label_default)
+			label_default:
+            *ostack++ = (*(u4 (*)())f)();
+            //printf("!!!!!!!!!!!!! called default JNIMethod %s!!!!!!!!!!\n",sig);
+        	goto empty_stack;
+    
+    empty_stack:
+
+	//Get rid of the items on the stack
+	if(nrofopsonstack > 0) {
+ 		__asm__ __volatile__("add sp,%0" ::"r"(nrofopsonstack): "sp");
+	}
+    return ostack;*/
+
+
+//    	r8 = (u4*)(*--opntr);
+//    	r9 = (u4*)(*--opntr);
+//    	r10 = (u4*)(*--opntr);
+//    	r11 = (u4*)(*--opntr);
+//    	r12 = env;
+
+
+
+/*    
+   	//write all operands to register
+    if(!class){
+    	switch(nrofopsinregister){
+    	case 4:
+   		__asm__ __volatile__(
+   			"ld.w r8,%[r8]		\n\t"
+   			"ld.w r9,%[r9]		\n\t"
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[r11]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r8]"m"(*--opntr),[r9]"m"(*--opntr),[r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)
+   			:"r8","r9","r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 3:
+   		__asm__ __volatile__(
+   			"ld.w r9,%[r9]		\n\t"
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[r11]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r9]"m"(*--opntr),[r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)
+   			:"r9","r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 2:
+   		__asm__ __volatile__(
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[r11]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)
+   			:"r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 1:
+   		__asm__ __volatile__(
+   			"ld.w r11,%[r11]	\n\t"
+   			"ld.w r12,%[env]"
+   			::[r11]"m"(*--opntr),[env]"m"(env)
+   			:"r11","r12"
+   			);
+   			goto select_function;
+   		case 0:
+   		__asm__ __volatile__(
+   			"ld.w r12,%[env]"
+   			::[env]"m"(env)
+   			:"r12"
+   			);
+   			goto select_function;
+   		}
+    }else{//class needs to be written to r11 
+    	switch(nrofopsinregister){
+    	case 3:
+   		__asm__ __volatile__(
+   			"ld.w r8,%[r8]		\n\t"
+   			"ld.w r9,%[r9]		\n\t"
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[class]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r8]"m"(*--opntr),[r9]"m"(*--opntr),[r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)
+   			:"r8","r9","r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 2:
+   		__asm__ __volatile__(
+   			"ld.w r9,%[r9]		\n\t"
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[class]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r9]"m"(*--opntr),[r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)
+   			:"r9","r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 1:
+   		__asm__ __volatile__(
+   			"ld.w r10,%[r10]	\n\t"
+   			"ld.w r11,%[class]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)
+   			:"r10","r11","r12"
+   			);
+   			goto select_function;
+    	case 0:
+   		__asm__ __volatile__(
+   			"ld.w r11,%[class]	\n\t"
+   			"ld.w r12,%[env]"
+   			:: [class]"m"(class),[env]"m"(env)
+   			:"r10","r11","r12"
+   			);
+   			goto select_function;
+    	}
+    }
+	select_function: //This label is put here to make some cleaner assembler jumps above
+	*/
+
+//    int isstatic;
+//    if(class){
+//    	isstatic = 1; 
+//    }else{
+//    	isstatic = 0;
+//    }
+//    printf("!!!!!!!!!!!!! calling JNIMethod (sig:%s) (type:%d) (argcount:%d) (static:%d)!!!!!!!!!!\n",sig,ret_type,args,isstatic);
+
+//Dit werkt!!!    
+//    if(args == 3 && isstatic == 0 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,*--opntr,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+/*
+    u4 *opntr = ostack + args;
+    long long *result;
+	if(class){
+		//printf("I am static!!!!!!!\n");
+		if(args == 0){
+      		//*ostack = (*(u4 (*)())f)(env,class);
+      		*result = (*(long long (*)())f)(env,class);
+    	}else if(args == 1){
+       		*result = (*(long long (*)())f)(env,class,*--opntr);
+       	}else if(args == 2){
+       		*result = (*(long long (*)())f)(env,class,*--opntr,*--opntr);
+       	}else if(args == 3){
+       		*result = (*(long long (*)())f)(env,class,*--opntr,*--opntr,*--opntr);
+       	}else if(args == 4){
+       		*result = (*(long long (*)())f)(env,class,*--opntr,*--opntr,*--opntr,*--opntr);
+       	}else if(args == 5){
+       		*result = (*(long long (*)())f)(env,class,*--opntr,*--opntr,*--opntr,*--opntr,*--opntr);
+       	}
+	}else{
+      	//printf("I am not static!!!!!!!\n");
+		if(args == 0){
+       		*result = (*(long long (*)())f)(env);
+       	}else if(args == 1){
+       		*result = (*(long long (*)())f)(env,*--opntr);
+       	}else if(args == 2){
+       		*result = (*(long long (*)())f)(env,*--opntr,*--opntr);
+       	}else if(args == 3){
+       		*result = (*(long long (*)())f)(env,*--opntr,*--opntr,*--opntr);
+       	}else if(args == 4){
+       		*result = (*(long long (*)())f)(env,*--opntr,*--opntr,*--opntr,*--opntr);
+       	}else if(args == 5){
+       		*result = (*(long long (*)())f)(env,*--opntr,*--opntr,*--opntr,*--opntr,*--opntr);
+       	}
+	}
+	
+	switch(ret_type) {
+        case RET_VOID:
+			printf("-------->Performed void function %s\n",sig);
+            break;
+
+        case RET_DOUBLE:
+        	*(double*)ostack = *(double(*))result;
+        	ostack += 2;
+			printf("-------->Performed double function %s,casting to %d\n",sig, ret_type);
+        	//printf("returned a double %f\n",*ostack);
+            break;
+
+        case RET_LONG:
+        	*(long long*)ostack = *(long long(*))result;
+        	ostack += 2;
+			printf("-------->Performed long function %s,casting to %d\n",sig, ret_type);
+        	//printf("returned a long %l\n",*ostack);
+            break;
+
+        case RET_FLOAT:
+        	*(float*)ostack = *(float(*))result;
+        	ostack++;
+			printf("-------->Performed float function %s,casting to %d\n",sig, ret_type);
+        	//printf("returned a float %f\n",*ostack);
+            break;
+
+        default:
+        	*ostack++ = *(u4(*))result;
+            //ostack++;
+			printf("-------->Performed default function %s,casting to %d\n",sig, ret_type);
+        	//printf("returned a default %d\n",*ostack);
+        	break;
+    }
+    return ostack;
+    */
+
+
+
+
+//    if(args == 3 && isstatic == 0 && ret_type == RET_DFLT){
+//       printf("I am here!!!!!!!\n");
+//       u4 *result = (*(u4 (*)())f)(env,*--opntr,*--opntr,*--opntr);
+//       *ostack++ = result;
+//       //*ostack++ = (*(u4 (*)())f)(env,*--opntr,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+//    if(args == 2 && isstatic == 0 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+//    if(args == 1 && isstatic == 0 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,*--opntr);
+//	   return ostack;
+//    }
+//    
+//    if(args == 6 && isstatic == 1 && ret_type == RET_DFLT){
+//       printf("I am here for 7 args..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,class,*--opntr,*--opntr,*--opntr,*--opntr,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+//    if(args == 4 && isstatic == 1 && ret_type == RET_DFLT){
+//       printf("I am here for 5 args..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,class,*--opntr,*--opntr,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+//    if(args == 3 && isstatic == 1 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,class,*--opntr,*--opntr,*--opntr);
+//	   return ostack;
+//    }
+//    if(args == 2 && isstatic == 1 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//      *ostack++ = (*(u4 (*)())f)(env,class,*--opntr,*--opntr);
+//	   return ostack;
+//   }
+//    if(args == 1 && isstatic == 1 && ret_type == RET_DFLT){
+//       printf("I am here..\n");
+//       *ostack++ = (*(u4 (*)())f)(env,class,*--opntr);
+//	   return ostack;
+//    }
+    
+    //int i;
+
+    //for(i = 0; i < args; i++){
+    //	printf("!!!!!should write arg %d\n",i);
+    	//__asm__ __volatile__("ld.w r11,%0" :: "m"(*--opntr):"r11");
+        //__asm__ __volatile__("st.w --sp,r11" ::: "sp","r11");
+    //}
+
+//	int i=args;
+//    if(class) {
+//    	for(i=args;i>3;i--){
+//	    	__asm__ __volatile__("ld.w r8,%0" :: "m"(*--opntr):"r8");
+//    		__asm__ __volatile__("st.w --sp,r8" ::: "sp","r8");
+//    	}
+//    	if(args >= 3){
+//    		__asm__ __volatile__("ld.w r8,%0" :: "m"(*--opntr):"r8");
+//    	}
+//    	if(args >= 2){
+//    		__asm__ __volatile__("ld.w r9,%0" :: "m"(*--opntr):"r9");
+//    	}
+//    	if(args >= 1){
+//    		__asm__ __volatile__("ld.w r10,%0" :: "m"(*--opntr):"r10");
+//    	}
+//    	__asm__ __volatile__("ld.w r11,%0" :: "m"(class):"r11");
+//	   	__asm__ __volatile__("ld.w r12,%0" :: "m"(env):"r12");
+//    }else{//static, don't add class variable
+//	   	for(i=args;i>4;i--){
+//	   		//r8 will be reused by the last register argument
+//    		__asm__ __volatile__("ld.w r8,%0" :: "m"(*--opntr):"r8");
+//    		__asm__ __volatile__("st.w --sp,r8" ::: "sp","r8");
+//    	}
+//    	if(args >= 4){
+//    		__asm__ __volatile__("ld.w r8,%0" :: "m"(*--opntr):"r8");
+//    	}
+//    	if(args >= 3){
+//    		__asm__ __volatile__("ld.w r9,%0" :: "m"(*--opntr):"r9");
+//    	}
+//    	if(args >= 2){
+//    		__asm__ __volatile__("ld.w r10,%0" :: "m"(*--opntr):"r10");
+//    	}
+//    	if(args >= 1){
+//    		__asm__ __volatile__("ld.w r11,%0" :: "m"(*--opntr):"r11");
+//    	}
+//    	__asm__ __volatile__("ld.w r12,%0" :: "m"(env):"r12");
+//    }
+
+//    printf("!!!!!pushing environment to r12\n");
+
+    //printf("!!!!!!!!!!!!! switching ret_type %s %d ,nr of args: %d!!!!!!!!!!\n",sig, ret_type,args);
+//    switch(ret_type) {
+//        case RET_VOID:
+//            (*(void (*)())f)();
+//            //printf("!!!!!!!!!!!!! called void JNIMethod %s!!!!!!!!!!\n",sig);
+//            break;
+//
+//        case RET_DOUBLE:
+//        	*(double*)ostack = (*(double (*)())f)();
+//            ostack += 2;
+//            //printf("!!!!!!!!!!!!! called double JNIMethod %s %l!!!!!!!!!!\n",sig,*ostack);
+//            break;
+//
+//        case RET_LONG:
+//        	*(long long*)ostack = (*(long long (*)())f)();
+//            ostack += 2;
+//            //printf("!!!!!!!!!!!!! called long JNIMethod %s %l!!!!!!!!!!\n",sig,*ostack);
+//            break;
+//
+//        case RET_FLOAT:
+//        	*(float*)ostack = (*(float (*)())f)();
+//            ostack++;
+//            //printf("!!!!!!!!!!!!! called float JNIMethod %s %f!!!!!!!!!!\n",sig,*ostack);
+//            break;
+//
+//        default:
+//            *ostack++ = (*(u4 (*)())f)();
+//            //printf("!!!!!!!!!!!!! called default JNIMethod %s!!!!!!!!!!\n",sig);
+//        	break;
+//    }
+//
+// if(class && args > 3) {
+// 		int to_add = args-3;
+// 		__asm__ __volatile__("add sp,%0" ::"r"(to_add): "sp");
+// }else if(!class && args > 4){
+// 		int to_add = args-4;
+// 		__asm__ __volatile__("add sp,%0" ::"r"(to_add): "sp");
+// }
+//    //printf("!!!!!!!!!!!!! returning JNIMethod (sig:%s) (type:%d) (argcount:%d)!!!!!!!!!!\n",sig,ret_type,args);
+//    //printf("!!!!!!!!!!!!! returning %s %d ,nr of args: %d!!!!!!!!!!\n",sig, ret_type,args);
+//    //printf("!!!!!!!!!!!!! returning JNIMethod !!!!!!!!!!\n");
+//    //__asm__ __volatile__ ("addl %0,%%esp" :: "r" ((args + 1) * sizeof(u4)) : "cc", "sp");
+//    
+//    return ostack;
+
+
+//write all operands, class and env to register
+#define WRITE_PARAMS(label)								\
+    if(!class){											\
+    	switch(nrofopsinregister){						\
+    	case 4:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r8,%[r8]		\n\t"					\
+   			"ld.w r9,%[r9]		\n\t"					\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[r11]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r8]"m"(*--opntr),[r9]"m"(*--opntr),[r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)						\
+   			:"r8","r9","r10","r11","r12"				\
+   			);											\
+   			goto label;									\
+    	case 3:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r9,%[r9]		\n\t"					\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[r11]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r9]"m"(*--opntr),[r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)						\
+   			:"r9","r10","r11","r12"						\
+   			);											\
+   			goto label;									\
+    	case 2:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[r11]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r10]"m"(*--opntr),[r11]"m"(*--opntr),[env]"m"(env)						\
+   			:"r10","r11","r12"							\
+   			);											\
+   			goto label;									\
+    	case 1:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r11,%[r11]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			::[r11]"m"(*--opntr),[env]"m"(env)			\
+   			:"r11","r12"								\
+   			);											\
+   			goto label;									\
+   		case 0:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r12,%[env]"							\
+   			::[env]"m"(env)								\
+   			:"r12"										\
+   			);											\
+   			goto label;									\
+   		}												\
+    }else{												\
+    	switch(nrofopsinregister){						\
+    	case 3:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r8,%[r8]		\n\t"					\
+   			"ld.w r9,%[r9]		\n\t"					\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[class]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r8]"m"(*--opntr),[r9]"m"(*--opntr),[r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)						\
+   			:"r8","r9","r10","r11","r12"				\
+   			);											\
+   			goto label;									\
+    	case 2:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r9,%[r9]		\n\t"					\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[class]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r9]"m"(*--opntr),[r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)						\
+   			:"r9","r10","r11","r12"						\
+   			);											\
+   			goto label;									\
+    	case 1:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r10,%[r10]	\n\t"					\
+   			"ld.w r11,%[class]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [r10]"m"(*--opntr),[class]"m"(class),[env]"m"(env)						\
+   			:"r10","r11","r12"							\
+   			);											\
+   			goto label;									\
+    	case 0:											\
+   		__asm__ __volatile__(							\
+   			"ld.w r11,%[class]	\n\t"					\
+   			"ld.w r12,%[env]"							\
+   			:: [class]"m"(class),[env]"m"(env)			\
+   			:"r10","r11","r12"							\
+   			);											\
+   			goto label;									\
+    	}												\
+    }													\
+	//This label is put here to make some cleaner assembler jumps above
+#endif
diff -urpN jamvm-1.5.0/src/os/linux/avr32/init.c jamvm-1.5.0-avr32/src/os/linux/avr32/init.c
--- jamvm-1.5.0/src/os/linux/avr32/init.c	1970-01-01 01:00:00.000000000 +0100
+++ jamvm-1.5.0-avr32/src/os/linux/avr32/init.c	2008-02-08 09:20:38.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2003, 2004, 2006, 2007
+ * Robert Lougher <rob@lougher.org.uk>.
+ *
+ * This file is part of JamVM.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+//#include <fpu_control.h>
+//#include <stdio.h>
+
+/* Change floating point precision to double (64-bit) from
+ * the extended (80-bit) Linux default. */
+
+//void setDoublePrecision() {
+//    fpu_control_t cw;
+//
+//    _FPU_GETCW(cw);
+//    cw &= ~_FPU_EXTENDED;
+//    cw |= _FPU_DOUBLE;
+//    _FPU_SETCW(cw);
+//}
+
+void initialisePlatform() {
+	//TODO: is this needed for avr32?    setDoublePrecision();
+}
diff -urpN jamvm-1.5.0/src/os/linux/avr32/Makefile.am jamvm-1.5.0-avr32/src/os/linux/avr32/Makefile.am
--- jamvm-1.5.0/src/os/linux/avr32/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ jamvm-1.5.0-avr32/src/os/linux/avr32/Makefile.am	2008-02-08 09:20:38.000000000 +0100
@@ -0,0 +1,25 @@
+##
+## Copyright (C) 2003, 2004, 2005, 2006, 2007
+## Robert Lougher <rob@lougher.org.uk>.
+##
+## This file is part of JamVM.
+##
+## This program is free software; you can redistribute it and/or
+## modify it under the terms of the GNU General Public License
+## as published by the Free Software Foundation; either version 2,
+## or (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program; if not, write to the Free Software
+## Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+##
+
+noinst_LTLIBRARIES = libnative.la
+libnative_la_SOURCES = init.c dll_md.c
+
+AM_CPPFLAGS = -I$(top_builddir)/src
diff -urpN jamvm-1.5.0/src/os/linux/avr32/Makefile.in jamvm-1.5.0-avr32/src/os/linux/avr32/Makefile.in
--- jamvm-1.5.0/src/os/linux/avr32/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ jamvm-1.5.0-avr32/src/os/linux/avr32/Makefile.in	2008-02-08 09:20:38.000000000 +0100
@@ -0,0 +1,446 @@
+# Makefile.in generated by automake 1.10 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/os/linux/avr32
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/src/config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libnative_la_LIBADD =
+am_libnative_la_OBJECTS = init.lo dll_md.lo
+libnative_la_OBJECTS = $(am_libnative_la_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(top_builddir)/src@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libnative_la_SOURCES)
+DIST_SOURCES = $(libnative_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+JAVAC = @JAVAC@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+arch = @arch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+interp_cflags = @interp_cflags@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+os = @os@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+use_zip_no = @use_zip_no@
+use_zip_yes = @use_zip_yes@
+with_classpath_install_dir = @with_classpath_install_dir@
+noinst_LTLIBRARIES = libnative.la
+libnative_la_SOURCES = init.c dll_md.c
+AM_CPPFLAGS = -I$(top_builddir)/src
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/os/linux/avr32/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/os/linux/avr32/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libnative.la: $(libnative_la_OBJECTS) $(libnative_la_DEPENDENCIES) 
+	$(LINK)  $(libnative_la_OBJECTS) $(libnative_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dll_md.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urpN jamvm-1.5.0/src/os/linux/Makefile.am jamvm-1.5.0-avr32/src/os/linux/Makefile.am
--- jamvm-1.5.0/src/os/linux/Makefile.am	2007-10-28 00:19:26.000000000 +0200
+++ jamvm-1.5.0-avr32/src/os/linux/Makefile.am	2008-02-08 09:20:38.000000000 +0100
@@ -20,7 +20,7 @@
 ##
 
 SUBDIRS = @arch@
-DIST_SUBDIRS = powerpc arm i386 x86_64 parisc mips
+DIST_SUBDIRS = powerpc arm i386 x86_64 parisc mips avr32
 
 noinst_LTLIBRARIES = libos.la
 libos_la_SOURCES = os.c
diff -urpN jamvm-1.5.0/src/os/linux/Makefile.in jamvm-1.5.0-avr32/src/os/linux/Makefile.in
--- jamvm-1.5.0/src/os/linux/Makefile.in	2007-10-29 07:02:37.000000000 +0100
+++ jamvm-1.5.0-avr32/src/os/linux/Makefile.in	2008-02-08 09:20:38.000000000 +0100
@@ -191,7 +191,7 @@ use_zip_no = @use_zip_no@
 use_zip_yes = @use_zip_yes@
 with_classpath_install_dir = @with_classpath_install_dir@
 SUBDIRS = @arch@
-DIST_SUBDIRS = powerpc arm i386 x86_64 parisc mips
+DIST_SUBDIRS = powerpc arm i386 x86_64 parisc mips avr32
 noinst_LTLIBRARIES = libos.la
 libos_la_SOURCES = os.c
 AM_CPPFLAGS = -I$(top_builddir)/src
